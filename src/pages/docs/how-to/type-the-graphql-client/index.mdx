export const metadata = {
	title: "Typing the GraphQL Client",
};

Faust.js provides built-in TypeScript support, including types for Templates, Blocks, and more. You can also generate fully typed definitions for your custom GraphQL queries and fragments using tools like [GraphQL Code Generator](https://the-guild.dev/graphql/codegen).

**Note:** If you’re looking to generate Apollo-specific fragment matching metadata (i.e. `possibleTypes`), see the `faust generatePossibleTypes` command. However, that command does **not** produce TypeScript definitions for your queries. For typing your queries in Faust, continue reading below.

## Steps

## 1. Basic Setup

If you haven’t already, follow the [Basic Setup](/docs/how-to/basic-setup/) steps to get Faust.js configured. Once your project is set up, add `@graphql-codegen/cli` to your project:

```bash
npm install -D typescript @graphql-codegen/cli
```

In the root of your project, create a configuration file named `codegen.ts`

```ts title="codegen.ts"
import { CodegenConfig } from "@graphql-codegen/cli";

const config: CodegenConfig = {
	schema: "https://faustexample.wpengine.com/graphql",
	documents: ["src/**/*.{tsx,ts}"],
	generates: {
		"./src/__generated__/": {
			preset: "client",
			plugins: [],
			presetConfig: {
				gqlTagName: "gql",
			},
		},
	},
	ignoreNoDocuments: true,
};

export default config;
```

Next, update your package.json to add a script for running the code generator:

```json title="package.json"
{
	"scripts": {
		"generate:types": "graphql-codegen"
	}
}
```

Now you can run:

```bash
npm run generate:types
```

This command will scan your `src/` folder for any GraphQL queries or fragments, then generate TypeScript types in `src/__generated__/graphql.ts`.

Be sure to enable WPGraphQL introspection before running `npm run generate: types`, since introspection is disabled by default on some WP hosting environments.

## Typing WP Template Pages

After Codegen runs, you’ll see auto-generated types in graphql.ts. For example:

```ts title="src/__generated__/graphql.ts"
export type GetPostQueryVariables = Exact<{
	databaseId: Scalars["ID"];
	asPreview?: InputMaybe<Scalars["Boolean"]>;
}>;

export type GetPostQuery = {
	// ...
};
```

You can use these types with the `FaustTemplate` helper in your WordPress templates:

```ts title="wp-templates/single.tsx"
import { gql } from '../__generated__';
import { GetPostQuery } from '../__generated__/graphql';
import { FaustTemplate } from '@faustwp/core';

const Component: FaustTemplate<GetPostQuery> = (props) => {
  // `props.data` and other fields are now typed!
  return <div>{props?.data?.post?.title}</div>;
};

export const pageQuery = gql(/* GraphQL */ `
  query GetPost($databaseId: ID!, $asPreview: Boolean) {
    ...
  }
`);

```

Then you can inspect all the types in the `props` parameters as you type:

![](./images/ts-image-one.png)

All the data from the query results will be properly typed based on the introspected schema:

![](./images/ts-image-two.png)

## Typing Block Components

If you create blocks with `@faustwp/blocks`, you can use the WordPressBlock type to add strong typing to those components:

```ts title="wp-blocks/CoreParagraph.tsx"

import { gql } from '../__generated__';
import { WordPressBlock } from '@faustwp/blocks';
import { CoreParagraphFragmentFragment } from '../__generated__/graphql';

const CoreParagraph: WordPressBlock<CoreParagraphFragmentFragment> = (props) => {
  return <p>{props.attributes?.content}</p>;
};

export const fragments = {
  entry: gql(`
    fragment CoreParagraphFragment on CoreParagraph {
      attributes {
        content
      }
    }
  `),
  key: 'CoreParagraphFragment',
};

```

By passing in `CoreParagraphFragmentFragment` to WordPressBlock, TypeScript enforces that props only contains fields you’ve declared in the GraphQL fragment.

## Typing Plugins with FaustHooks

When creating Faust plugins, you can use the `FaustHooks` type to get autocompletion and type-safety for the hooks system:

```ts title="plugins/ProjectTemplatePlugin.ts"
import { FaustHooks, FaustPlugin } from "@faustwp/core";

export class ProjectTemplatePlugin implements FaustPlugin {
	constructor() {}

	apply(hooks: FaustHooks) {
		hooks.addFilter("possibleTemplatesList", "faust", (templates, data) => {
			if (data?.seedNode?.__typename === "Project") {
				return Array.from(new Set(["project", ...templates]));
			}
			return templates;
		});
	}
}
```

Because `FaustHooks` knows about available filters and hooks, TypeScript will automatically guide you on what the callback signatures should look like.

![](./images/typescript-fausthooks-type.png)

## Migrating Existing Pages to TypeScript

Finally, if you have existing Next.js pages that you want to migrate to TypeScript, you can follow the official TypeScript Docs for general TypeScript migration tips.

For Faust, you’ll often make use of the following types:

- `FaustTemplate` for WP Template pages.
- `WordPressBlock` for block components.
- `GetStaticProps`, `GetServerSideProps`, and `GetStaticPaths` from Next.js for data-fetching methods.
- `FaustHooks` for hooking into the Faust plugin system.

Here’s a quick example using `[...wordpressNode].tsx`:

```ts title="pages/[...wordpressNode].tsx"
import { getWordPressProps, WordPressTemplate } from '@faustwp/core';
import { GetStaticPaths, GetStaticProps } from 'next';

export type WordPressTemplateProps = Parameters<typeof WordPressTemplate>[0];

export default function Page(props: WordPressTemplateProps) {
  return <WordPressTemplate {...props} />;
}

export const getStaticProps: GetStaticProps = (ctx) => {
  return getWordPressProps({ ctx });
};

export const getStaticPaths: GetStaticPaths = () => {
  return {
    paths: [],
    fallback: 'blocking',
  };
};

```

Since we aren’t explicitly passing a type to `WordPressTemplate`, we can use the `Parameters` utility type to automatically derive the correct prop shape.
